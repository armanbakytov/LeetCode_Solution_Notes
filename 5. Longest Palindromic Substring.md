# Problem
Given a string `s`, return _the longest_ _palindromic_ _substring_in `s`.

**Example 1:**
**Input:** `s = "babad"`
**Output:** `"bab"`
**Explanation:** "aba" is also a valid answer.

**Example 2:**
**Input:** `s = "cbbd"`
**Output:** `"bb"`

**Constraints:**
- `1 <= s.length <= 1000`
- `s` consist of only digits and English letters.

# Solution

The simplest approach is to assume that the initial `s` is a palindrome, and if we meet in the middle, comparing `s[left] == s[right]` the we've been right. And if we're not, reduce the size of the array by 1 an try again with sub-arrays.

>So 1 array of size `N`, 2 of `N-1`, 3 of `N-2`, 4 of `N-3`, ...

The other is the same idea, but rather, we build from down up instead of up to the bottom. take any symbol from the middle, expand. But then, its the same algorithm, with $\theta (n)$ being a bit slower.
```pseudocode

for (int size = s.length; size > 0; size--){
	for(int left = 0; left <= s.length - size; left++){
		l = left;
		r = size;
		while(l < r){
			if (s[r] != s[l]) break;
			l++; r--;
		}
		return s.getSeq(left, size);
	}
}
```

# Code
```java
public String longestPalindrome(String s) {  
    for (int size = s.length(); size > 0; size--){  
        for(int left = 0; left <= s.length() - size; left++){  
            int right =size-1 + left;  
            int l = left;  
            int r = right;  
            boolean found = true;  
            while(l <= r){  
                if (s.charAt(r) != s.charAt(l)) {  
                    found = false;  
                    break;  
                }  
                l++; r--;  
            }  
            if(found) return s.substring(left, right+1);  
        }  
    }  
    return s.substring(0, 0);  
}
```
---
On a second thought, expand from center might be a better approach, cause although you might get the biggest palindrome a bit faster, its still an $O(n^3)$ algorithm.

