Given an array `nums` of size `n`, return _the majority element_.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

**Example 1:**
**Input:** nums = `[3,2,3]`
**Output:** 3

**Example 2:**
**Input:** nums = `[2,2,1,1,1,2,2]`
**Output:** 2

**Constraints:**
- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`
- The input is generated such that a majority element will exist in the array.

**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?

# Solution
Ok, its quite easy to solve it with linear time, but how can we solve it with O(1) space complexity?

When using a set and with the assumption that the majority exists we will have at most n/2 elements in that map (majority + distinct n-1 elems) considering that the last majority element is in the end of array to verify. Still O(n) though.

Have I solved any problems that had O(1) complexity? Let's build from here. This might reflect and give me an idea.

Ok, scratch that, still no idea, let me solve it in O(n) O(n) first

# Solution
```java
public int majorityElement(int[] nums) {  
    Map<Integer, Integer> map = new HashMap<>();  
    for(int elem : nums){  
        if(!map.containsKey(elem))  
            map.put(elem, 0);  
        else  
            map.put(elem, (int) map.get(elem) + 1);  
    }  
    int ans = map.entrySet().stream()
    .max(Comparator.comparing(Map.Entry::getValue))
    .get().getKey();  
    return ans;  
}
```

# Can we actually devise a way to solve in O(1) Space?
I think something might click if i visualize the nums as a graph, we already know that someone is already winning by half yeah. Just for the sake of fun, let's think of recent New York Mayor elections.

Mamdani:
---------------------------------
Cuomo:
---------------------------
Silwa:
-------

Say we are playing a game in which I just have to find who is Mamdani and what's his index is.

> Even if I substract Cuomo and Silwa from Mamdani, Mamdani would still remain with %'s.

That's how these guys may look in an Array:

MMMCSMSSSMMCMMMSSMSSMMCSSCCCCCMCCCCSMMMCCSSCC

But how do I find Mamdani?

Say now I can't know the actual election candidates and only have letters now

AAABBCABCCBCBBCAACBCAC..........

I know!!!!

Imagine we are playing building blocks, where we remove building blocks from 3 towers. And we don't know which tower is the tallest because the weather today is awful. How would you get to know which tower is the tallest if the Boss tell you can only choose them in specific order (ABCAAA)?

I know it's a bit of a messy idea, but bear with me. Say I get AA first, assume its the A is tallest, and substract any B or C that I get. For every two floors of A, I removed one B and C. And if apparently I get another letter, and the A just had no floors to choose, I can just change to another letter.

By the end, its just just as if I've done `Even if I substract Cuomo and Silwa from Mamdani, Mamdani would still remain with %'s.` kind of operation!
# Solution
```java
public int majorityElement(int[] nums) {  
    int assumption = -1;  
    int count = 0;  
    for (int elem: nums){  
        if(count == 0) {assumption = elem; count = 1  }
        else{  
            count += (assumption == elem) ? 1: -1;  
        }  
    }  
    return assumption;  
}
```

No need for the else statement
```java
public int majorityElement(int[] nums) {  
    int assumption = -1;  
    int count = 0;  
    for (int elem: nums){  
        if(count == 0) assumption = elem;
            count += (assumption == elem) ? 1: -1;  
    }  
    return assumption;  
}
```
>Look at that beautiful solution!

>Next thing, is I need to refine my idea derival, and tidy my idea flow above, but bear with me.