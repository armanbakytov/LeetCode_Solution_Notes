Given an array `nums` of size `n`, return _the majority element_.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

**Example 1:**
**Input:** nums = `[3,2,3]`
**Output:** 3

**Example 2:**
**Input:** nums = `[2,2,1,1,1,2,2]`
**Output:** 2

**Constraints:**
- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`
- The input is generated such that a majority element will exist in the array.

**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?

# Solution
Ok, its quite easy to solve it with linear time, but how can we solve it with O(1) space complexity?

When using a set and with the assumption that the majority exists we will have at most n/2 elements in that map (majority + distinct n-1 elems) considering that the last majority element is in the end of array to verify. Still O(n) though.

Have I solved any problems that had O(1) complexity? Let's build from here. This might reflect and give me an idea.

Ok, scratch that, still no idea, let me solve it in O(n) O(n) first

# Solution
```java
public int majorityElement(int[] nums) {  
    Map<Integer, Integer> map = new HashMap<>();  
    for(int elem : nums){  
        if(!map.containsKey(elem))  
            map.put(elem, 0);  
        else  
            map.put(elem, (int) map.get(elem) + 1);  
    }  
    int ans = map.entrySet().stream()
    .max(Comparator.comparing(Map.Entry::getValue))
    .get().getKey();  
    return ans;  
}
```

# Can we actually devise a way to solve in O(1) Space?
I think something might click if i visualize the nums as a graph, we already know that someone is already winning by half yeah. Just for the sake of fun, let's think of recent New York Mayor elections.

Mamdani:
---------------------------------
Cuomo:
---------------------------
Silwa:
-------

Say we are playing a game in which I just have to find who is Mamdani and what's his index is.

> Even if I substract Cuomo and Silwa from Mamdani, Mamdani would still remain with %'s.

That's how these guys may look in an Array:

MMMCSMSSSMMCMMMSSMSSMMCSSCCCCCMCCCCSMMMCCSSCC

But how do I find Mamdani?

Say now I can't know the actual election candidates and only have letters now

AAABBCABCCBCBBCAACBCAC..........

I know!!!!
## Raw Idea
```
Imagine we are playing building blocks, where we remove building blocks from 3 towers. And we don't know which tower is the tallest because the weather today is awful. How would you get to know which tower is the tallest if the Boss tell you can only choose them in specific order (ABCAAA)?

I know it's a bit of a messy idea, but bear with me. Say I get AA first, assume its the A is tallest, and substract any B or C that I get. For every two floors of A, I removed one B and C. And if apparently I get another letter, and the A just had no floors to choose, I can just change to another letter.

By the end, its just just as if I've done `Even if I substract Cuomo and Silwa from Mamdani, Mamdani would still remain with %'s.` kind of operation!
```
## Refined Idea
>I thought a bit on how to put the correct analogy, dumped it with messy word to chatGPT, and this is what I wanted to say basically.

Imagine three empires on a battlefield:
**A**, **B**, and **C**.
They all show up with their armies, but they follow one very stupid rule:

> Whenever two soldiers from _different_ empires meet, they immediately kill each other.

> No strategy. No tactics. Just instant mutual destruction.

You don’t keep track of how many troops each empire has; you just watch the chaos unfold in the exact order soldiers appear.

Now, here’s the catch:
> One empire brought **more than half** of all troops on the entire battlefield.

Your job is to figure out **which empire that is**, but you’re only allowed:
- to walk through the battlefield once, and
- to keep track of **one current empire** and **one number**.
### **How the war plays out**
You walk along the line of soldiers:
1. If you currently have **no champion empire**,
    you let the current soldier’s side become your “champion.”
2. When a soldier appears:
    - If he’s from your **champion empire**, he increases your trust (count++).
    - If he’s from a **different empire**, they mutually kill:
        - one champion soldier
        - one enemy soldier
            (count--)        
            
When count becomes 0, it means:
> “All champion soldiers so far have been killed off by enemies—reset and pick the next guy as champion.”

This is your “cancellation” mechanic.

---
### **Why the majority empire MUST survive**
Since one empire has **more than half** the troops:
- Even if every possible soldier-on-soldier cancellation happens,
- And even if enemies gang up on the champion empire, that majority empire **cannot be fully wiped out**. (Mamdani Example)

Eventually:
- All the smaller empires cancel each other and drain away,
- And the only group that can still produce surviving soldiers is the **true majority empire**.

So the empire that remains as the **champion** after processing the entire line must be the majority.

---
# Solution
```java
public int majorityElement(int[] nums) {  
    int assumption = -1;  
    int count = 0;  
    for (int elem: nums){  
        if(count == 0) {assumption = elem; count = 1  }
        else{  
            count += (assumption == elem) ? 1: -1;  
        }  
    }  
    return assumption;  
}
```


No need for the else statement
```java
public int majorityElement(int[] nums) {  
    int assumption = -1;  
    int count = 0;  
    for (int elem: nums){  
        if(count == 0) assumption = elem;
            count += (assumption == elem) ? 1: -1;  
    }  
    return assumption;  
}
```
>Look at that beautiful solution!

>Next thing, is I need to refine my idea derival, and tidy my idea flow above, but bear with me.