Given an array `nums` of size `n`, return _the majority element_.

The majority element is the element that appears more than `⌊n / 2⌋` times. You may assume that the majority element always exists in the array.

**Example 1:**
**Input:** nums = `[3,2,3]`
**Output:** 3

**Example 2:**
**Input:** nums = `[2,2,1,1,1,2,2]`
**Output:** 2

**Constraints:**
- `n == nums.length`
- `1 <= n <= 5 * 104`
- `-109 <= nums[i] <= 109`
- The input is generated such that a majority element will exist in the array.

**Follow-up:** Could you solve the problem in linear time and in `O(1)` space?

# Solution
Ok, its quite easy to solve it with linear time, but how can we solve it with O(1) space complexity?

When using a set and with the assumption that the majority exists we will have at most n/2 elements in that map (majority + distinct n-1 elems) considering that the last majority element is in the end of array to verify. Still O(n) though.

Have I solved any problems that had O(1) complexity? Let's build from here. This might reflect and give me an idea.

Ok, scratch that, still no idea, let me solve it in O(n) O(n) first

# Solution
```java
public int majorityElement(int[] nums) {  
    Map<Integer, Integer> map = new HashMap<>();  
    for(int elem : nums){  
        if(!map.containsKey(elem))  
            map.put(elem, 0);  
        else  
            map.put(elem, (int) map.get(elem) + 1);  
    }  
    int ans = map.entrySet().stream()
    .max(Comparator.comparing(Map.Entry::getValue))
    .get().getKey();  
    return ans;  
}
```