# Problem
Given an integer array `nums`, return `true` if any value appears **at least twice** in the array, and return `false` if every element is distinct.

**Example 1:**
**Input:** nums = `[1,2,3,1]`
**Output:** true

**Explanation:**
The element 1 occurs at the indices 0 and 3.

**Example 2:**
**Input:** nums = `[1,2,3,4]`
**Output:** false

**Explanation:**
All elements are distinct.

**Example 3:**
**Input:** nums = `[1,1,1,3,3,4,3,2,4,2]`
**Output:** true

**Constraints:**
- `1 <= nums.length <= 105`
- `-10^9 <= nums[i] <= 10^9`

# Solution

Ok, the length of the nums is quite small, so I would prefer exploiting a bit more of memory instead in favour of time complexity.

With using HashMap, we should be able to get O(n) complexity.

Store occurences in the map, `if(map.containsKey(nums[i])) return true;`. And false by the end of array

# Code
```java
public boolean containsDuplicate(int[] nums) {
	Map<Integer, Integer> map = new HashMap<>();
	for(int elem : nums){
		if(map.containsKey(elem)) return true;
		else map.put(elem, elem);
	}
	return false;
}
```

>Lightwork. No reaction.

# Some refinements...
To actually improve my coding skills and not feed my ego by solving LeetCode easy problems I occasionally ask ChatGPT for some feedback.

Here are main criteria he gave me:
1. You don’t need a** **Map<Integer, Integer>
2. Storing elem is weird
3. Map used like a Set = instant side-eye.

>And to be fair, I have to agree. That was a bit naïve to use map as a set. When declaring a map I also hesitated a bit thinking "Oh wait but what value am I supposed to store though". Let's fix that.

```java
public boolean containsDuplicate(int[] nums) {
	Set<Integer> set = new HashSet<>();
	for(int elem : nums){
		if(!set.add(elem)) return true; //add returns false is the element is already present
	}
	return false;
}
```
![[Pasted image 20251209041926.png]]
>Boom. from 54th Percentile to 84th, on Java.

