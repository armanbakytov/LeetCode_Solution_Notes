Problem [link](https://leetcode.com/problems/longest-substring-without-repeating-characters/)

# Problem
Given a string `s`, find the length of the **longest** **substring** without duplicate characters.

**Example 1:**
>**Input:** s = "abcabcbb"
>**Output:** 3
>**Explanation:** The answer is "abc", with the length of 3. Note that `"bca"` and `"cab"` are also correct answers.

**Example 2:**
>**Input:** s = "bbbbb"
>**Output:** 1
>**Explanation:** The answer is "b", with the length of 1.

**Example 3:**
>**Input:** s = "pwwkew"
>**Output:** 3
>**Explanation:** The answer is "wke", with the length of 3.
>Notice that the answer must be a substring, "pwke" is a subsequence and not a substring.

**Constraints:**
- `0 <= s.length <= 5 * 104`
- `s` consists of English letters, digits, symbols and spaces

# Solution

The first intuition is to keep a dictionary of Symbols in a HashMap. Then keep two pointers left and right, if the new element right is already present in the Map, we would like to stop. What the case of the repetition would look like??

## `__a___b_____a__b___a`
##
We would have to find that element in the array, and continue our way from here

>Should I just keep on linear searching for the element a, or shall I keep a HashMap `Symbol --> Index`?

HashMap would require memory, Linear Search might require time...

We have $10^4$ Elements, and maybe like a couple hundred ASCII symbols. So a HashMap is better!

Ok lets see how this goes.

```Initial Code structure
//Create a HashMap char --> Index
int max = 0;
for(int i = 0; i < arr.length; i++){
	if(Hashmap.contains(arr[i])){
		HashMap.put(arr[i]);
		
		if(max < length) max = length;
		length = 0;
	}
	length++;
}
```

On a second thought, I would have to erase all the elements that came before a. So no need to overwrite the same HashMap, dump the old one, get a new one instead. 

But wait! Why not just keep the record of the last recorded??? One HashMap that is built on the GO! And if you have the element in the Map, then just update the index, and record the score.

`O(n)` then, huh? :)

P.S. One thing to note as well. Say we have this sequence
## `b__a___b_____a`
##
Say I encounter an a, and say i get `last = Map.get(char)`, the next length(the sandwich in between) wouldn't just be `length = i - last - 1`,  but rather i would have to check with `left` which is the leftmost char of the sequence, and `if (left < last) left = last`. This way I won't run into the problem of encountering a and calculating from left `a` but rather left `b`

>P.S. I was so confused when my initial tests failed but failed on `abba` sequence. After checking how the code operates in Debug mode I finally found my mistake.
# Final Code
```java
public static int lengthOfLongestSubstring(String s) {  
    int max = 0;  
    int length = 0;  
    int left = 0;  
    Map<Character, Integer> SymbolToInd = new HashMap<>();  
    for(int i = 0; i < s.length(); i++){  //advance the right
        Character key =  s.charAt(i);  
        if(SymbolToInd.containsKey(key)){  //if the key is present
            int last = SymbolToInd.get(key);  //get the left element of out sequence
            if(left < last) left = last;  //update if last occurence of new element is bigger
            if (max < length) max =length;  //update max
            length = i - left - 1;  // -1. because we add +1 after (compute the meat of the sandwich and then add bread :D )
        }  
        SymbolToInd.put(key, i);  //add this key anyways
        length++;  
    }  
    if (max < length) max =length;  
    return max;  
}
```

# Some minor refinements
Looking Back into my code, I believe it would make it cleaner to just go with left and right concept, and compute the length on the go. So the code becomes:
```java
public static int lengthOfLongestSubstring(String s) {  
    int max = 0;  
    int length = 0;  
    int left = 0;  
    Map<Character, Integer> map = new HashMap<>();  
    for(int right = 0; right < s.length(); right++){  
        Character key =  s.charAt(right);  
  
        if(map.containsKey(key) && left <= map.get(key)){  
            left = map.get(key) + 1; //move past, ignore the bread, get the meat 
        }  
  
        map.put(key, right);  
        length = right - left + 1;  
        if (max < length) max = length;  
    }  
    return max;  
}
```

> Look at how elegant that piece of code looks.