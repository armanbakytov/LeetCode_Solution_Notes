# Problem Description
You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

>**Input:** `l1 = [2,4,3], l2 = [5,6,4]`
>**Output:** `[7,0,8]`
>**Explanation:** `342 + 465 = 807`.

**Example 2:**

>**Input:** `l1 = [0], l2 = [0]`
>**Output:** `[0]`

**Example 3:**

>**Input:**` l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]`
>**Output:** `[8,9,9,9,0,0,0,1]`
>**Explanation:** `9999999 + 9999`

**Constraints:**

- The number of nodes in each linked list is in the range `[1, 100]`.
- `0 <= Node.val <= 9`
- It is guaranteed that the list represents a number that does not have leading zeros.

# Solution Process

>The digits are stored in the reverse order

>We have a singly linked-list, so, no going back.

> It's just like adding numbers in high-school. Add two numbers, keep the carry to the next digit

```
//traverse each nodes of linked lists
sum = node1 + node2
rem =  sum%10 + carry;
carry = sum < 10 ? 0 : 1;
next = new Node(rem)
curr.next = next;
curr = next;
```
---
```java
public ListNode addTwoNumbers(ListNode l1, ListNode l2) {  
    int[] sum = addTwoNodes(l1, l2, 0);  
    ListNode head = new ListNode(sum[0]);  
    ListNode curr = head;  
    ListNode next;  
    l1 = l1.next; l2 = l2.next;  
    
    while(l1 != null || l2 != null || sum[1] != 0){  
        //parse the values if present  
        sum = addTwoNodes(l1, l2, sum[1]);  
          
        //create the next node  
        next = new ListNode(sum[0]);  
        curr.next = next;  
          
        //traverse further  
        curr = next;  
        l1 = (l1 == null) ? l1 : l1.next;  
        l2 = (l2 == null) ? l2 : l2.next;  
    }  
  
    return head;  
}  
  
public int[] addTwoNodes (ListNode l1, ListNode l2, int carry){  
    int s1 = (l1 == null) ? 0 : l1.val;  
    int s2 = (l2 == null) ? 0 : l2.val;  
  
    int sum = s1 + s2 + carry;  
    int rem = sum%10;  
    int newCarry = (sum < 10) ? 0 : 1;  
      
    return new int[] {rem, newCarry};  
}
```

First, for simplicity and code reusage, I created a new function called `addTwoNodes`, which will check if nodes are not null, and will add them giving us the remainder and the carry. Makes out life easier because I can use it in my code repeatedly. Also makes it easier to debug if I made any mistakes.

I calculate the first sum, create a head object reference. Make the current node point to head.

And in the while loop we:
1. Add two nodes using our function
2. Create the next node
3. Traverse Further

This function encapsulated design helps to solve this problem easily avoiding extra time wasted debugging the code.