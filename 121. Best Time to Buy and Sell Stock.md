#Easy

> I am currently making a small warmup for the Upcoming Citi Interview, and also preparing for the Java finals. Killing two birds with a single shot :)
# Problem
You are given an array `prices` where `prices[i]` is the price of a given stock on the `ith` day.

You want to maximize your profit by choosing a **single day** to buy one stock and choosing a **different day in the future** to sell that stock.

Return _the maximum profit you can achieve from this transaction_. If you cannot achieve any profit, return `0`.

**Example 1:**

**Input:** prices = `[7,1,5,3,6,4]`
**Output:** 5
**Explanation:** Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.
Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.

**Example 2:**

**Input:** prices = `[7,6,4,3,1]`
**Output:** 0
**Explanation:** In this case, no transactions are done and the max profit = 0.

**Constraints:**

- `1 <= prices.length <= 105`
- `0 <= prices[i] <= 104`

# Solution

Ok the problem seems quite easy, I will use two pointers for min and max

But the main issue is that I must not allow the min.ind > max.ind

To make it easier to think, lets say I consider them separately

min:
1. Take the first element as the min
2. Compare each next element to min
3. If smaller swap
4. End when by the end of array
max:
5. Take the first element as max
6. Compare each next to max
7. If bigger swap the value for new one
8. End by the end of array

# ------min------max----n

When updating the max i need to keep a separate min for the ranges `[max.ind, n]`

in which min inside that range would be bigger.

then:
```cpp
max = prices[n];
min = min_range; //min range could be left as that until the min swap
```
> Also don't forget that the condition to update the max is `max-min < elem - min_range`

when we encounter a new min:
- Store it in the min_range
- And swap it to min only when you encounter a new max;


## Some things I missed on the first try
As I've been writing the code, I realized that we only have to store the value of the min_range only if `min_range > elem`, at first I thought that I have to update `min`. But such condition might fail in case like `[1,2,5]`.

I ran debug with breakpoint to see what's actually happening under the hood, and fount the bug was in that element.
# Final code
```java
public static int maxProfit(int[] prices) {  
    int max = prices[0];  
    int min = prices[0];  
    int min_range = prices[0];  
    for(int elem : prices){  
        if(max - min < elem - min_range){  
            max = elem;  
            min = min_range;  
        }  
        if(min_range > elem){  
            min_range = elem;  
        }  
    }  
    return max-min;  
}
```